# 排序算法

## 蛮力法

一种简单直接地解决问题的方法，直接基于问题的描述和涉及的概念定义

- 唯一一个能够应用于所有问题的策略

- 肯定会给出一种对应的解，不受数据规模的限制

- 可能比设计一个好的算法需要更少的时间

- 给出一个问题解的时间复杂度上界，衡量其它算法的时间效率

### 选择排序

每次遍历未排序的整个列表，选择一个最小的与第一个没有被交换的进行交换，下一次从被交换的下一个元素开始遍历

```
SelectionSort(A[0...n-1])
	// 用选择排序对给定的数组进行排序
	// 输入：需要排序的数组
	// 输出：升序排序的数组
	for i <- 0 to n-2 do
		min <- i
		for j <- i+1 to n-1 do
			if A[j] < A[min]
				min <- j
		swap A[i] and A[min]
```

比较次数：<img src="pic\2\1.png" style="zoom:50%;" />

交换次数：n-1次

最好最坏情况：没有最好最坏情况，不管怎样，都要判断这么多次，都要交换这么多次

### 冒泡排序

n从第一个元素开始遍历列表直到不确定位置的最后一个元素，如果相邻元素是逆序则交换位置；每一次遍历后，有一个元素被放到对应的位置上。

```
Algorithm BubbleSort(A[0...n-1])
	// 该算法用冒泡排序算法对给定的数组进行排序
	// 输入：一个可排序的数组
	// 输出：升序排列的数组
	for i <- 0 to n-2 do
		for j<- 0 to n-2-i do
			if A[j+1] < A[j]
				swap A[j] and A[j+1]
```

比较次数：<img src="pic\2\2.png" style="zoom:50%;" />

交换次数

- 最坏情况：和比较次数相同
- 最好情况：不需要交换

改进：如果第一次结束发现没有交换的则停止

### 计算多项式

多项式：<img src="pic\2\3.png" style="zoom:70%;" />

蛮力：θ（n^2）

<font color="red">**霍纳法则**</font>：θ（n）

把x作为公因子从将次以后的剩余多项式中提取出来：<img src="pic\2\4.png" style="zoom:60%;" />

```
p(x) = 2x^4 - x^3 -3x^2 + x - 5
     = x(2x^3 - x^2 -3x + 1) - 5
     = x(x(2x^2 - x - 3) + 1) - 5
     = x(x(x(2x - 1) - 3) + 1) - 5
```

```
Horner(P[0...n], x)
	// 用霍纳法则求一个多项式在一个给定点的值
	// 输入：一个n次多项式的系数数组P[0...n]（从低到高存储），以及一个数字x
	// 输出：多项式在x点的值
	p <- P[n]
	for i <- n-1 downto 0 do
		p <- x * p + P[i]
	return p
```

乘法次数、加法次数：n

具体实现见```HuoNaRule.java```

体现了变治法和时空权衡，和动态规划有密切联系

### 交替放置的碟子

有数量为2n的一排碟子，n黑n白交替放置：黑白黑白…现在要将所有白色的放在左边，黑色的放在右边，但是只允许交换相邻的两个碟子实现。请设计一个完成该任务的算法，并计算执行交换位置的次数。

n=1：1次

n=2：2+1=3次

```
O   · | O   ·
· | O   · | O
·   ·   O   O
```

```n + (n-1) + ... + 1 = (n^2+n)/2```

具体实现见```BlackWhite.java```

### 求一个数值数组中大小最接近的两个元素的差

```
Algorithm MinDistance(A[0...n-1])
	// 输入：数字数组A[0...n-1]
	// 输出：数组中两个大小差距最小的元素的差值
	dmin <- ∞
	for i <- 0 to n-1 do
		for j <- 0 to n-1
			if i <- j and |A[i] - A[j]| < dmin
				dmin <- |A[i] - A[j]|
	return dmin
```

改进：先排序，然后计算相邻元素的差

## 分治法

### 归并排序

### 快速排序

## 减治法

### 插入排序

## 变治法

### 预排序

## 时空排序

### 计数排序

