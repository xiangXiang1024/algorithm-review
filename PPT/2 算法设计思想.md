# 排序算法

## 蛮力法

一种简单直接地解决问题的方法，直接基于问题的描述和涉及的概念定义

- 唯一一个能够应用于所有问题的策略

- 肯定会给出一种对应的解，不受数据规模的限制

- 可能比设计一个好的算法需要更少的时间

- 给出一个问题解的时间复杂度上界，衡量其它算法的时间效率

### 选择排序

每次遍历未排序的整个列表，选择一个最小的与第一个没有被交换的进行交换，下一次从被交换的下一个元素开始遍历

```
SelectionSort(A[0...n-1])
	// 用选择排序对给定的数组进行排序
	// 输入：需要排序的数组
	// 输出：升序排序的数组
	for i <- 0 to n-2 do
		min <- i
		for j <- i+1 to n-1 do
			if A[j] < A[min]
				min <- j
		swap A[i] and A[min]
```

比较次数：<img src="pic\2\1.png" style="zoom:50%;" />

交换次数：n-1次

最好最坏情况：没有最好最坏情况，不管怎样，都要判断这么多次，都要交换这么多次

### 冒泡排序

n从第一个元素开始遍历列表直到不确定位置的最后一个元素，如果相邻元素是逆序则交换位置；每一次遍历后，有一个元素被放到对应的位置上。

```
Algorithm BubbleSort(A[0...n-1])
// 该算法用冒泡排序算法对给定的数组进行排序
// 输入：一个可排序的数组
// 输出：升序排列的数组
for i <- 0 to n-2 do
	for j <- 0 to n-2-i do
		if A[j+1] < A[j]
			swap A[j] and A[j+1]
```

比较次数：<img src="pic\2\2.png" style="zoom:50%;" />

交换次数

- 最坏情况：和比较次数相同
- 最好情况：不需要交换

改进：如果第一次结束发现没有交换的则停止

### 计算多项式

多项式：<img src="pic\2\3.png" style="zoom:70%;" />

蛮力：θ（n^2）

<font color="red">**霍纳法则**</font>：θ（n）

把x作为公因子从将次以后的剩余多项式中提取出来：<img src="pic\2\4.png" style="zoom:60%;" />

```
p(x) = 2x^4 - x^3 -3x^2 + x - 5
     = x(2x^3 - x^2 -3x + 1) - 5
     = x(x(2x^2 - x - 3) + 1) - 5
     = x(x(x(2x - 1) - 3) + 1) - 5
```

```
Algorithm Horner(P[0...n], x)
// 用霍纳法则求一个多项式在一个给定点的值
// 输入：一个n次多项式的系数数组P[0...n]（从低到高存储），以及一个数字x
// 输出：多项式在x点的值
p <- P[n]
for i <- n-1 downto 0 do
	p <- x * p + P[i]
return p
```

乘法次数、加法次数：n

具体实现见```HuoNaRule.java```

体现了变治法和时空权衡，和动态规划有密切联系

### 交替放置的碟子

有数量为2n的一排碟子，n黑n白交替放置：黑白黑白…现在要将所有白色的放在左边，黑色的放在右边，但是只允许交换相邻的两个碟子实现。请设计一个完成该任务的算法，并计算执行交换位置的次数。

n=1：1次

n=2：2+1=3次

```
O   · | O   ·
· | O   · | O
·   ·   O   O
```

```n + (n-1) + ... + 1 = (n^2+n)/2```

具体实现见```BlackWhite.java```

### 求一个数值数组中大小最接近的两个元素的差

```
Algorithm MinDistance(A[0...n-1])
// 输入：数字数组A[0...n-1]
// 输出：数组中两个大小差距最小的元素的差值
dmin <- ∞
for i <- 0 to n-1 do
	for j <- 0 to n-1
		if i <- j and |A[i] - A[j]| < dmin
			dmin <- |A[i] - A[j]|
return dmin
```

改进：先排序，然后计算相邻元素的差

## 分治法

- 将一个问题划分为同一类型的若干子问题，子问题最好规模相同
- 对这些子问题求解（一般采用递归方法）
- 有必要的话，合并这些子问题的解，以得到原始问题的答案

<img src="pic\2\5.png" style="zoom:50%;" />

能够使用分治策略的问题一般具有如下特质：

- 问题规模缩小到一定程度就很容易解决
- 问题能够划分为多个相互独立的子问题

### 主定理

- 顺序算法
  - T<sub>s</sub>(n)= a * T<sub>s</sub>(n/b)+ f(n)
  - 分解为b份，其中a份需要求解，f(n)表示合并需要的时间

- 并行算法：
  - T<sub>p</sub>(n)= T<sub>s</sub>(n/b)+ f(n)

<img src="E:\大学\研一中\高级算法\algorithm-review\PPT\pic\2\6.png" style="zoom:50%;" />

例如，计算a<sub>0</sub>+a<sub>1</sub>+…+a<sub>n-1</sub>=(a<sub>0</sub>+…+a<sub>⎿n/2⏌-1</sub> )+(a<sub>⎿n/2⏌</sub>+…+a<sub>n-1</sub> )需要的加法次数

​	A(n) = 2A(n/2) + 1，a=2, b=2, d=0

​	=>   a > b<sup>d</sup>

​	=>   A(n) ∈Θ(n<sup>log<sub>b</sub> a</sup>) =Θ(n)

### 合并排序

将一个需要排序的数组A[0..n-1]一分为两个子数组：A[0..⎿n/2⏌-1] 和A[⎿n/2⏌..n-1]，分别对两个子数组排序，最后将两个子数组合并

```
Algorithm MergeSort(A[0...n-1])
// 递归调用MergeSort对数组合并排序
// 输入：一个可排序的数组
// 输出：升序排列的数组
if n > 1
	copy A[0...⎿n/2⏌-1] to B[0...⎿n/2⏌-1]
	copy A[⎿n/2⏌...n-1] to C[0...⎿n/2⏌-1]
	MergeSort(B[0...⎿n/2⏌-1])
	MergeSort(C[0...⎿n/2⏌-1])
	Merge(B, C, A)
	
Algorithm Merge(B[0...p-1], C[0...q-1], A[0...p+q-1])
	// 将两个有序数组合并为一个有序数组
	i <- 0; j <- 0; k <- 0
	while i < p and j < q do
		if B[i] <= C[j] then 
			A[k] <- B[i]
			i <- i+1
		else 
			A[k] <- C[j]
			j <- j+1
		k <- k+1
	if i = p
		copy C[j...q-1] to A[k...p+q-1]
	else
		copy B[i...p-1] to A[k...p+q-1]
```

- 键值比较次数
  - C(n) = 2C(n/2) + C<sub>merge</sub>(n), C(1) = 0
  - 最坏情况：C<sub>merge</sub>(n) = n-1
  - C<sub>worst</sub> = 2C<sub>worst</sub>(n/2) + n - 1 ∈Θ(nlogn) 

#### 求数组逆序对个数

利用归并排序思路。在 merge 时，比较元素时可加入计算逆序对的步骤。

```java
public int mergeSort(int[] array, int[] tmp, int low, int high) {
    if(low >= high) {
        return 0;
    }
    int result = 0;
    int mid = (low + high) / 2 + low;
    result += mergeSort(array, tmp, low, mid);
    result += mergeSort(array, tmp, mid+1, high);
    result += merge(array, tmp, low, mid, high);
    return result;
}
private int merge(int[] array, int[] tmp, int low, int mid, int high) {
    int i1 = low, i2 = mid+1, k = low, result = 0;
    while(i1 <= mid && i2 <= high) {
        if(array[i1] > array[i2]) {
            result += mid + 1 - i1;	// 只是多了这句
            tmp[k] = array[i2];
            k++;
            i2++;
        }else {
            tmp[k] = array[i1];
            k++;
            i1++;
        }
        while(i1 <= mid) {
            tmp[k] = array[i1];
            k++;
            i1++;
        }
        while(i2 <= high) {
            tmp[k] = array[i2];
            k++;
            i2++;
        }
        for(int i = low ; i <= high ; i++) {
            array[i] = tmp[i];
        }
    return result;
}
```

### 快速排序

按照元素的值对它们进行划分

对所有n元素进行分区，使得在下标s前的元素的值都小于等于下标为s的元素值，之后的则大于s位置的元素值

n建立这样的分区后，下标为s的元素所在的位置与目标升序数组中的位置相同；接下来就是对前后两个分区的数据使用同样的方式进行分区；直到每一个分区都只有一个元素

```
Algorithm QuickSort(A[l...r])
// 用快速排序方法对子数组进行排序
// 输入：一个可排序的数组
// 输出：非降序排列的数组
if l < r then s <- Partition(A[l...r])	// s是分裂的位置
QuickSort(A[l...s-1])
QuickSort(A[s+1...r])

Algorithm Partition(A[l...r])
// 以第一个元素为中轴，将子数组分区
// 输入：原数组的一个子数组，通过下标定义区间
// 输出：原数组中的分裂点
p <- A[l]; i <- l; j <- r+1
repeat
	repeat i <- i+1 until A[i] >= p	// 找到大于或等于中轴的准备交换
	repeat j <- j-1 until A[j] <= p	// 找到小于或等于中轴的准备交换
	swap(A[i], A[j])
until i >= j
swap(A[i], A[j]) // 当i>=j，撤销最后一次交换
swap(A[l], A[j])
return j
```

时间复杂度

- 最好情况
  - 选择的中轴恰好是每一个数组的中值点，则满足通用分治递推公式
  - C<sub>best</sub>(n) = 2C<sub>best</sub>(n/2) + C<sub>partition</sub>
  - 最好的情况下partition时出现i=j，比较的次数是n，即C<sub>partition</sub>=n
  - C<sub>best</sub>(n) = 2C<sub>best</sub>(n/2) + n => C<sub>best</sub>(n) ∈Θ(nlogn) 
- 最坏情况
  - 分区并不能带来效率上的提升，即不满足递推公式，最不满足的情况是原来就是升序的
  - 每次只会从第一个位置将数组Partition
  - k次后剩下的元素为n-k，需要比较的次数是(n+1)-k+1；直到第n-1次比较3次后结束
  - C<sub>worst</sub> (n) = (n+1) + n + (n-1) + … + 3 = (n+1) (n+2) / 2 - 3 ∈ Θ(n^2)
- 平均情况
  - C<sub>avg</sub> (n) = 1/n ∗ ∑<sub>s=0</sub><sup>n-1</sup>(C<sub>avg</sub> (s) + C<sub>avg</sub> (n-1-s) + (n+1))

## 减治法

### 插入排序

## 变治法

### 预排序

## 时空排序

### 计数排序

