# 蛮力法

一种简单直接解决问题 方法，常常直接基于问题的描述和所涉及的概念定义

枚举、穷举、暴力解法

体现蛮力法的一些解决问题的方案

- 搜索所有解空间
  - 找约束条件、找枚举范围：在搜索前尽可能减小搜索空间
- 搜索所有路径
- 直接计算
- 模拟和仿真

选择排序、冒泡排序

## 顺序查找

在给定的列表中查找一个给定的值

- 遍历列表直到找到给定的元素

- 需要判断列表是否结束
  - 技巧：将给定元素放到列表结尾，最后判断一次是否是列表的结尾

- 时间复杂度：Θ(n)

确定搜索空间，在空间内根据限制条件顺序查找

- 白鸡百钱问题
  - 中国古代数学家张丘建在《算经》中提出了著名的“百鸡百钱问题”：鸡翁一，值钱五；鸡母一值钱三；鸡雏三，值钱一；百钱买百鸡，翁、母、雏各几何？
  - 算法设计1
    - 3个需要确定的值，各有空间；有一个限制条件
    - 遍历整个搜索空间
  - 算法设计2
    - 三个变量之间就有一个限制条件，只要遍历其中两个的空间即可
    - 额外发现雏必须是3的倍数

- n求所有的三位数，它除以11所得的余数等于它的三位数字的平方和
  - 三位数只有900个
  - 除以11的余数只有11种可能，0不算，只有10个
  - 三个数平方和小于等于10的必定都小于等于3
  - 百位数不等于0
- 某公司有N层楼，为了测出哪层楼最高，可以使用一种仪器从天花板向地板自由落体，仪器不会摔坏；如果有两个一模一样的仪器，请设计一个最佳效率类型的算法解决这个问题

## 字符串匹配

给定一个n个字符组成的串，称为文本，一个m(m<=n)个字符的串，称为模式，从文本中寻找匹配模式的子串

蛮力解法

- 以文本中的每一个字符为开始字符，用模式串去匹配，直到文本结束

- 最糟糕的情况下算法效率属于Θ(nm)

- 可以认为大多数移动的情况都是发生在很少的比较次数之后，因此算法的平均效率比最坏情况要好的多
  - 随机查找文本的时候，显示出线性效率Θ(n+m) = Θ(n)

```
Algorithm BruteForceStringMatch(T[0...n-1], P[0...m-1])
// 蛮力字符串匹配
// 输入：一个n个字符的数组T[0...n-1]，代表一段文本
//      一个m个字符的数组P[0...m-1]，代表一段模式
// 输出：如果查询成功，返回文本的第一个匹配子串中第一个字符的位置
//      否则返回-1
for i <- 0 to n-m do
	j <- 0
	while j < m and P[j] = T[i+j] do
		j <- j+1
		if j = m
			return i
return -1
```

最坏情况：O(mn)

例. 给定一个文本CADFBAAXBYA，计算以A开始以B结束的字符串个数

- 联想一下：区间包含点个数的问题？是否有关联？

## 最近对问题

